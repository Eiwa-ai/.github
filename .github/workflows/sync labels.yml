name: Sync Labels Across Organization

on:
  push:
    branches:
      - main  # or master, depending on your default branch name
    paths:
      - '.github/labels.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  sync-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Get list of organization repositories
        id: org-repos
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ORG_PAT }}
          script: |
            const org = context.repo.owner;
            const repos = await github.paginate(github.rest.repos.listForOrg, {
              org: org,
              type: 'all'
            });
            return repos.map(repo => repo.full_name);
        
      - name: Sync labels for each repository
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_PAT }}
        with:
          github-token: ${{ secrets.ORG_PAT }}
          script: |
            const repositories = ${{ steps.org-repos.outputs.result }};
            const fs = require('fs');
            const yaml = require('js-yaml');
            
            const labelsYml = fs.readFileSync('.github/labels.yml', 'utf8');
            const labels = yaml.load(labelsYml);
            
            for (const repo of repositories) {
              await github.rest.issues.listLabelsForRepo({
                owner: repo.split('/')[0],
                repo: repo.split('/')[1]
              }).then(async ({data: currentLabels}) => {
                const currentLabelNames = currentLabels.map(label => label.name);
                const newLabelNames = labels.map(label => label.name);
                
                // Remove old labels
                for (const label of currentLabelNames) {
                  if (!newLabelNames.includes(label)) {
                    await github.rest.issues.deleteLabel({
                      owner: repo.split('/')[0],
                      repo: repo.split('/')[1],
                      name: label
                    });
                  }
                }
                
                // Merge duplicated labels
                for (const label of labels) {
                  await github.rest.issues.createLabel({
                    owner: repo.split('/')[0],
                    repo: repo.split('/')[1],
                    ...label
                  }).catch(async (err) => {
                    if (err.status === 422) {
                      // Label already exists, update it
                      await github.rest.issues.updateLabel({
                        owner: repo.split('/')[0],
                        repo: repo.split('/')[1],
                        name: label.name,
                        ...label
                      });
                    }
                  });
                }
              });
            }
